<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode-232. Implement Queue using Stacks</title>
    <link href="/2026/02/12/LeetCode-232-Implement-Queue-using-Stacks/"/>
    <url>/2026/02/12/LeetCode-232-Implement-Queue-using-Stacks/</url>
    
    <content type="html"><![CDATA[<blockquote><p>題目：<a href="https://leetcode.com/problems/implement-queue-using-stacks/description/">232. Implement Queue using Stacks</a></p></blockquote><h1 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h1><p>要用 stack 實作出一個 queue<br>要具備的操作：</p><ul><li>檢查 queue 是否為空</li><li>psuh 資料到 queue 中</li><li>從 queue 中 pop 出資料</li><li>從 queue peek 出資料來查看（但資料不移除）</li><li>建立 queue</li></ul><h1 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h1><p>這一題考研時上過類似的題目，標準解法就是用兩個 stack 去模擬 queue 的狀態<br>這邊是把左邊 stack（稱為 <code>myL</code>）設為 front；右邊 stack （稱為 <code>myR</code>）設為 back<br>各種操作如下圖所示：</p><p>初始狀態，檢查 queue 是否為空時也是如此圖，需要兩個 stack 都為空才是為空<br><img src="/source/_posts/LeetCode-232-Implement-Queue-using-Stacks/%E7%A9%BA%E4%BD%87%E5%88%97.png" alt="空佇列"></p><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>分為兩個情況：</p><ol><li>情況一：在進行此輪 push 以前都還沒 pop 過<br> 判斷條件：左邊 stack 是否為空？（true）</li><li>情況二：在進行此輪 push 前有先 pop 過資料<br> 判斷條件：左邊 stack 是否為空？（false）</li></ol><h3 id="情況一：在進行此輪-push-以前都還沒-pop-過"><a href="#情況一：在進行此輪-push-以前都還沒-pop-過" class="headerlink" title="情況一：在進行此輪 push 以前都還沒 pop 過"></a>情況一：在進行此輪 push 以前都還沒 pop 過</h3><blockquote><p>判斷條件：左邊 stack 是否為空？（true）</p></blockquote><p>此時程式碼撰寫只需要檢查左 stack 是否為空即可，這裡原因和 pop 的動作會涉及的操作有關<br>佇列為空和初始狀態要 push 是最好處理的，只需要 push 到右 stack 即可</p><p><img src="/source/_posts/LeetCode-232-Implement-Queue-using-Stacks/push%E6%83%85%E6%B3%81%E4%B8%80.png" alt="push情況一"></p><h3 id="情況二：在進行此輪-push-前有先-pop-過資料"><a href="#情況二：在進行此輪-push-前有先-pop-過資料" class="headerlink" title="情況二：在進行此輪 push 前有先 pop 過資料"></a>情況二：在進行此輪 push 前有先 pop 過資料</h3><blockquote><p>判斷條件：左邊 stack 是否為空？（false）</p></blockquote><p>步驟：</p><ol><li>先把左邊 stack 的資料全部乾坤大挪移回右邊 stack</li><li>這時才是正確的順序，才可以 push 新資料<br><img src="/source/_posts/LeetCode-232-Implement-Queue-using-Stacks/push%E6%83%85%E6%B3%81%E4%BA%8C.png" alt="push情況二"></li></ol><h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><p>這是最麻煩的操作，因為 Queue FIFO 的特性，當右邊 stack 不為空時，就要把右邊 stack 所有元素 pop 出來以 pop ˋ<br>出來的順序再度 push 到左邊 stack 中<br>這時候資料在左邊 stack 中的順序才會符合 Queue FIFO 該有的樣子<br>才能進行 pop<br><img src="/source/_posts/LeetCode-232-Implement-Queue-using-Stacks/pop.png" alt="pop"></p><h2 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h2><p>和 pop 的處理邏輯一樣，都要乾坤大挪移順序才會正確，唯一差別只在回傳時不需要用 pop 而是用 peek</p><h2 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h2><p>確認兩個 stack 都為空就代表 queue 為空了</p><hr><p>但有點好笑的是，如果用 java 寫這一題會變成用 Deque 模擬的 stack 再去模擬題目要求的 queue，因為 java 官方不建議用已經過時的 <code>Stack</code> 類別去實作 stack 出來，而是改為建議用介面 Deque 去實作出 <code>ArrayDeque</code> 以模擬 Stack </p><p><img src="/source/_posts/LeetCode-232-Implement-Queue-using-Stacks/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E9%9A%8E%E5%B1%A4%E5%9C%96.jpg" alt="java Collections Framework 階層圖"></p><h1 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    Deque&lt;Integer&gt; mqL;<br>    Deque&lt;Integer&gt; mqR;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 用Dequeue 實作 Stack 以製造出 Queue</span><br><br>        <span class="hljs-comment">// 需要製造兩個 Stack 以形成 Queue</span><br>        <span class="hljs-built_in">this</span>.mqL = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.mqR = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// 如果左邊stack為空才是初始狀態</span><br>        <span class="hljs-comment">// 這時只需要簡單的 push 到右邊的 stack 就好</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.mqL.isEmpty())&#123;<br>            <span class="hljs-built_in">this</span>.mqR.push(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 左邊 stack 不為空，代表前面有經過 pop 動作了</span><br>        <span class="hljs-comment">// 代表在進行新的 push 以前</span><br>        <span class="hljs-comment">// 要把左邊的 stack 再進行一次乾坤大挪移，push 回右邊的 stack</span><br>        <span class="hljs-comment">// 順序才不會亂掉</span><br>            <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.mqL.isEmpty())&#123;<br>                <span class="hljs-built_in">this</span>.mqR.push( <span class="hljs-built_in">this</span>.mqL.pop() );<br>            &#125;<span class="hljs-comment">//這時順序對了</span><br>            <span class="hljs-comment">// 才可以 push 真正的新資料到右邊 stack</span><br>            <span class="hljs-built_in">this</span>.mqR.push(x);<br>        &#125;<br>        <br>        <span class="hljs-comment">// push 操作簡單，只要放到右邊的 stack 即可</span><br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 從右邊的 stack 把所有元素都 pop 出來</span><br>        <span class="hljs-comment">// 再以 pop 出來的順序 push 到左邊的 stack</span><br>        <span class="hljs-comment">// 再從左邊的 stack 中 pop 出一個元素</span><br>        <span class="hljs-comment">// 這時出來的就是 Queue 順序的 pop 元素了</span><br>        <br>        <span class="hljs-comment">// 直到右邊stack為空為止...都持續 pop 出元素，然後 push 到左邊 stack</span><br>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.mqR.isEmpty())&#123;<br>            <span class="hljs-built_in">this</span>.mqL.push( <span class="hljs-built_in">this</span>.mqR.pop() );<br>        &#125; <span class="hljs-comment">// 這時所有元素都進到左邊 stack 了</span><br>        <span class="hljs-comment">// pop 出一個元素並回傳</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.mqL.pop();<br>        <br>    &#125;<br>    <span class="hljs-comment">// 取出一個元素查看他的值但不拿走他</span><br>    <span class="hljs-comment">// 除了回傳值以外基本都和上一個 pop() 相同操作</span><br>    <span class="hljs-comment">// 同樣要乾坤大挪移</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.mqR.isEmpty())&#123;<br>            <span class="hljs-built_in">this</span>.mqL.push( <span class="hljs-built_in">this</span>.mqR.pop() );<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.mqL.peek();<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 只有左右兩個 stack 皆為空才算是佇列真正為空</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.mqR.isEmpty() &amp;&amp; <span class="hljs-built_in">this</span>.mqL.isEmpty());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>另外叫 gemini 寫的有 main 可以看執行結果的版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayDeque;<br><span class="hljs-keyword">import</span> java.util.Deque;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackImplementsQueue</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 初始化 Queue</span><br>        <span class="hljs-type">MyQueue</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyQueue</span>();<br>        System.out.println(<span class="hljs-string">&quot;=== 開始測試 ===&quot;</span>);<br><br>        <span class="hljs-comment">// 1. Push 1</span><br>        System.out.println(<span class="hljs-string">&quot;Action: Push 1&quot;</span>);<br>        obj.push(<span class="hljs-number">1</span>);<br>        obj.printDebug(); <span class="hljs-comment">// 查看目前 Stack 狀態</span><br><br>        <span class="hljs-comment">// 2. Push 2</span><br>        System.out.println(<span class="hljs-string">&quot;Action: Push 2&quot;</span>);<br>        obj.push(<span class="hljs-number">2</span>);<br>        obj.printDebug();<br><br>        <span class="hljs-comment">// 3. Push 3</span><br>        System.out.println(<span class="hljs-string">&quot;Action: Push 3&quot;</span>);<br>        obj.push(<span class="hljs-number">3</span>);<br>        obj.printDebug();<br><br>        <span class="hljs-comment">// 4. Push 4</span><br>        System.out.println(<span class="hljs-string">&quot;Action: Push 4&quot;</span>);<br>        obj.push(<span class="hljs-number">4</span>);<br>        obj.printDebug();<br><br>        <span class="hljs-comment">// 5. Pop (預期應該是 1)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">val1</span> <span class="hljs-operator">=</span> obj.pop();<br>        System.out.println(<span class="hljs-string">&quot;Action: Pop -&gt; 取得: &quot;</span> + val1 + <span class="hljs-string">&quot; (預期: 1)&quot;</span>);<br>        obj.printDebug();<br><br>        <span class="hljs-comment">// 6. Push 5 (關鍵步驟！這裡最容易錯)</span><br>        System.out.println(<span class="hljs-string">&quot;Action: Push 5&quot;</span>);<br>        obj.push(<span class="hljs-number">5</span>);<br>        obj.printDebug();<br><br>        <span class="hljs-comment">// 7. Pop (預期應該是 2)</span><br>        <span class="hljs-comment">// 如果這裡印出 5，代表 push 5 的時候沒有處理好順序</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">val2</span> <span class="hljs-operator">=</span> obj.pop();<br>        System.out.println(<span class="hljs-string">&quot;Action: Pop -&gt; 取得: &quot;</span> + val2 + <span class="hljs-string">&quot; (預期: 2)&quot;</span>);<br>        obj.printDebug();<br><br>        <span class="hljs-comment">// 8. Pop (預期應該是 3)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">val3</span> <span class="hljs-operator">=</span> obj.pop();<br>        System.out.println(<span class="hljs-string">&quot;Action: Pop -&gt; 取得: &quot;</span> + val3 + <span class="hljs-string">&quot; (預期: 3)&quot;</span>);<br>        obj.printDebug();<br><br>        <span class="hljs-comment">// 9. Pop (預期應該是 4)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">val4</span> <span class="hljs-operator">=</span> obj.pop();<br>        System.out.println(<span class="hljs-string">&quot;Action: Pop -&gt; 取得: &quot;</span> + val4 + <span class="hljs-string">&quot; (預期: 4)&quot;</span>);<br>        obj.printDebug();<br><br>        <span class="hljs-comment">// 10. Pop (預期應該是 5)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">val5</span> <span class="hljs-operator">=</span> obj.pop();<br>        System.out.println(<span class="hljs-string">&quot;Action: Pop -&gt; 取得: &quot;</span> + val5 + <span class="hljs-string">&quot; (預期: 5)&quot;</span>);<br>        obj.printDebug();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 你的 MyQueue 類別 (稍微修改成 static 方便在 main 執行，並加入 debug 印出功能)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    Deque&lt;Integer&gt; mqL;<br>    Deque&lt;Integer&gt; mqR;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.mqL = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.mqR = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.mqL.isEmpty()) &#123;<br>            <span class="hljs-built_in">this</span>.mqR.push(x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 左邊 stack 不為空，先把左邊倒回右邊</span><br>            <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.mqL.isEmpty()) &#123;<br>                <span class="hljs-built_in">this</span>.mqR.push(<span class="hljs-built_in">this</span>.mqL.pop());<br>            &#125;<br>            <span class="hljs-comment">// 放入新元素</span><br>            <span class="hljs-built_in">this</span>.mqR.push(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 把右邊全部倒到左邊</span><br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.mqR.isEmpty()) &#123;<br>            <span class="hljs-built_in">this</span>.mqL.push(<span class="hljs-built_in">this</span>.mqR.pop());<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.mqL.pop();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.mqR.isEmpty()) &#123;<br>            <span class="hljs-built_in">this</span>.mqL.push(<span class="hljs-built_in">this</span>.mqR.pop());<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.mqL.peek();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.mqR.isEmpty() &amp;&amp; <span class="hljs-built_in">this</span>.mqL.isEmpty());<br>    &#125;<br><br>    <span class="hljs-comment">// === 這是我幫你加的上帝視角工具 ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDebug</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;   [狀態監控] 左Stack(mqL): &quot;</span> + mqL + <span class="hljs-string">&quot; | 右Stack(mqR): &quot;</span> + mqR);<br>        System.out.println(<span class="hljs-string">&quot;--------------------------------------------------&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>執行結果：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">=== 開始測試 ===</span><br>Action: Push 1<br><span class="hljs-code">   [狀態監控] 左Stack(mqL): [] | 右Stack(mqR): [1]</span><br><span class="hljs-code">--------------------------------------------------</span><br><span class="hljs-code">Action: Push 2</span><br><span class="hljs-code">   [狀態監控] 左Stack(mqL): [] | 右Stack(mqR): [2, 1]</span><br><span class="hljs-code">--------------------------------------------------</span><br>Action: Push 3<br><span class="hljs-code">   [狀態監控] 左Stack(mqL): [] | 右Stack(mqR): [3, 2, 1]</span><br><span class="hljs-code">--------------------------------------------------</span><br><span class="hljs-code">Action: Push 4</span><br><span class="hljs-code">   [狀態監控] 左Stack(mqL): [] | 右Stack(mqR): [4, 3, 2, 1]</span><br><span class="hljs-code">--------------------------------------------------</span><br>Action: Pop -&gt; 取得: 1 (預期: 1)<br><span class="hljs-code">   [狀態監控] 左Stack(mqL): [2, 3, 4] | 右Stack(mqR): []</span><br><span class="hljs-code">--------------------------------------------------</span><br><span class="hljs-code">Action: Push 5</span><br><span class="hljs-code">   [狀態監控] 左Stack(mqL): [] | 右Stack(mqR): [5, 4, 3, 2]</span><br><span class="hljs-code">--------------------------------------------------</span><br>Action: Pop -&gt; 取得: 2 (預期: 2)<br><span class="hljs-code">   [狀態監控] 左Stack(mqL): [3, 4, 5] | 右Stack(mqR): []</span><br><span class="hljs-code">--------------------------------------------------</span><br><span class="hljs-code">Action: Pop -&gt; 取得: 3 (預期: 3)</span><br><span class="hljs-code">   [狀態監控] 左Stack(mqL): [4, 5] | 右Stack(mqR): []</span><br><span class="hljs-code">--------------------------------------------------</span><br>Action: Pop -&gt; 取得: 4 (預期: 4)<br><span class="hljs-code">   [狀態監控] 左Stack(mqL): [5] | 右Stack(mqR): []</span><br><span class="hljs-code">--------------------------------------------------</span><br><span class="hljs-code">Action: Pop -&gt; 取得: 5 (預期: 5)</span><br><span class="hljs-code">   [狀態監控] 左Stack(mqL): [] | 右Stack(mqR): []</span><br><span class="hljs-code">--------------------------------------------------</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 3827. Count Monobit Integers（Weekly Contest 487）</title>
    <link href="/2026/02/07/LeetCode-3827-Count-Monobit-Integers%EF%BC%88Weekly-Contest-487%EF%BC%89/"/>
    <url>/2026/02/07/LeetCode-3827-Count-Monobit-Integers%EF%BC%88Weekly-Contest-487%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>題目：<a href="https://leetcode.com/problems/count-monobit-integers/description/">3827.Count Monobit Integers</a></p></blockquote><h1 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h1><p>給予一個數字 <code>n</code>，要求回傳 <code>0~n</code> 中二進位制的數字由左到右全部相同的數字之數量，這種數字稱為 Monobit。<br>例如：</p><ul><li><p>給定 <code>n=1</code>（0~1）<br>因為 $0_{10}&#x3D;0_2,  1_{10}&#x3D;1_{2}$<br>，所以回傳值是 2</p></li><li><p>給定 <code>n=4</code>（0~4）<br>因為只有<br>$0_{10}&#x3D;0_2, 0_{10}&#x3D;0_2,  3_{10}&#x3D;11_2$<br>符合條件，所以回傳值是 3</p></li></ul><h1 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h1><p>根據題意可以發現所謂 Monobit 有個規律，所有的 Monobit 除了 $0$ 以外，他們的二進位制全部都是由 $1$ 組成的，因為只有奇數才有可能全部為 1，所以我一開始的思路是用回圈遍歷 0~n 所有數字，然後用 if 判斷式只讓奇數進入下一階段的判斷，以及在這個回圈內宣告一個布林值作為開關。<br>並使用 java 內建的進制轉換 API <code>Integer.toBinaryString(i)</code> 回傳該數字的二進制之<strong>字元陣列</strong><br>再針對該字元陣列進行逐元素比對，一旦裡面出現 0 ，就把布林值設為 false，並且 break 不檢查後面的元素，跳出回圈，檢查下一個 i 是否為 Monobit。<br>等整個字元陣列跑完後，判斷布林值沒有被設為 false 後，讓計數器 +1<br>重複上述動作直到看完 n 這個數字。</p><p>程式碼如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countMonobit</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 0~n</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// n&gt;=2</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span><span class="hljs-number">2</span>; <span class="hljs-comment">// 預先加入 0 &amp; 1 的份</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>; i&lt;=n; i++)&#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">same</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 每檢查新的一個數字都要用新的判斷變數</span><br>            <span class="hljs-comment">// 只有奇數有可能是全1（全0的除了0以外沒有了）</span><br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 只讓奇數通過</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">binaryString</span> <span class="hljs-operator">=</span> Integer.toBinaryString(i); <span class="hljs-comment">//  [1,1], [1,0,1], [1,1,1]</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> binaryString.length();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;len; j++)&#123;<br>                    <span class="hljs-keyword">if</span>(binaryString.charAt(j) == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                        same = <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(same) num++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不過要注意容易出錯的點是「比對二進制中是否出現 0」這一點，因為 <code>Integer.toBinaryString(i)</code> 回傳值是一個字元陣列 <code>char[]</code>，裡面的元素是 <code>char</code> 而非 <code>int</code>，因此要比對是否出現 0 的話，也應該使用同樣型態的 <code>char</code> 而非 <code>int</code>，也就是 if 判斷式中要寫的是 <code>&#39;0&#39;</code> 而非 <code>0</code><br>否則 <code>&#39;0&#39;</code> 直接和 <code>int</code> 型態的 <code>0</code> 比對會變成 ASCII code 之間的比對，因為 <code>&#39;0&#39;</code> 的 ACSCII code &#x3D; 48，那 <code>48 != 0</code>，就會錯誤判斷成「裡面沒有出現 0」，導致這個判斷區塊永遠不成立，答案永遠是錯誤的，要多注意這點。</p><p>另一個問題是，這個方法的時間複雜度取決於 n &#x3D; 數字的數量以及 len &#x3D; 每個數字轉換成二進位之長度（位數），時間大約是 $O(n logn)$<br>後來在其他的解法看到這個更鬼的方法，直接用數學特性一行解決，因為覺得太厲害了在此紀錄下：</p><blockquote><p>參考自：<a href="https://leetcode.com/problems/count-monobit-integers/solutions/7541203/1-line-by-pitcherpunchst-c5ge">1 line</a></p></blockquote><p>他的思路是既然 monobit 只有 0, 1, 11, 111, 1111, … 等數字，可以發現說除了 0 以外，剩餘 monobit 都是全為 1 之數字，因為：</p><ul><li>$1_2&#x3D; 2^1 - 1 &#x3D; 2 - 1$</li><li>$11_2 &#x3D; 2^2 - 1 &#x3D; 4-1$</li><li>$111_2 &#x3D; 2^3 - 1 &#x3D; 8 - 1$</li><li>… 以此類推<br>可以找到這些 Monobit 的規律公式是 $2^k-1$，而 <code>k</code> 的值正好等於 0 以外的 Monobit 之數量，因為：$111_2 &#x3D; 2^3 - 1 &#x3D; 8 - 1$ 為例，這時假設 n&#x3D;7，可以回傳的 Monobit 有 0,1,3,7，扣除 0 以外正好 3 個 &#x3D; k 的值，所以只要回傳 <code>k 值 +1</code> 就是正確答案。<br>那接下來的重點就是找到這個 k 應該是多少了</li></ul><p>而 k 的找法：<br>需要建立 n 和 k 之間的等式，同樣以 $111_2 &#x3D; 2^3 - 1 &#x3D; 8 - 1$ 為例，這時 $2^3 -1&#x3D;7$，正好等於 7<br>可以寫出等式$$2^k - 1 \le n$$，假設 n&#x3D;7，那 $2^1- 1$,$2^2-1$, $2^3-1$ 都是合法值</p><p>以此等式進行一項以求出 k 值：</p><p>$$2^k &#x3D; n+1$$</p><p>$$\rightarrow k &#x3D; \log_2(n+1)$$</p><p>因此 k 值等於對 (n+1) 取 $log_2$ 值</p><p>而實際的程式碼撰寫，因為 java 沒有內建的 $\log_2$ 函數，只有以 $e$ 為底的自然對數 $\log_e &#x3D; \ln$，所以使用換底公式的概念算出：$$\log_A(B)&#x3D; \dfrac{\log_C(B)}{\log_C(A)}$$因此$$\log_2(n+1) &#x3D; \dfrac{\log_e(n+1)}{\log_e(2)}$$<br>那麼就可以寫出程式碼如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countMonobit</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(Math.log(n+<span class="hljs-number">1</span>) / Math.log(<span class="hljs-number">2</span>)) +<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>weekly-contest</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EXCEL雙因子變異數分析(無交互&amp;有交互)</title>
    <link href="/2026/02/06/EXCEL%E9%9B%99%E5%9B%A0%E5%AD%90%E8%AE%8A%E7%95%B0%E6%95%B8%E5%88%86%E6%9E%90-%E7%84%A1%E4%BA%A4%E4%BA%92/"/>
    <url>/2026/02/06/EXCEL%E9%9B%99%E5%9B%A0%E5%AD%90%E8%AE%8A%E7%95%B0%E6%95%B8%E5%88%86%E6%9E%90-%E7%84%A1%E4%BA%A4%E4%BA%92/</url>
    
    <content type="html"><![CDATA[<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul><li><a href="https://youtu.be/hc8eUL4soaw?si=DXXe_hWhSPSmBWUd">EXCEL雙因子變異數分析(無交互)</a></li><li><a href="https://youtu.be/BeNB3blTOZI?si=aFsbi_ZprCncS2wy">雙因子變異數分析例題</a></li></ul><h1 id="無交互"><a href="#無交互" class="headerlink" title="無交互"></a>無交互</h1><h4 id="1-輸入資資料後，點擊-資料分析，選取-雙因子變異數分析：無重複試驗"><a href="#1-輸入資資料後，點擊-資料分析，選取-雙因子變異數分析：無重複試驗" class="headerlink" title="1. 輸入資資料後，點擊 資料分析，選取 雙因子變異數分析：無重複試驗"></a>1. 輸入資資料後，點擊 <code>資料分析</code>，選取 <code>雙因子變異數分析：無重複試驗</code></h4><p>無重複試驗是指每一種因子A和因子B的組合之樣本 n&#x3D;1 的情況，這種試驗只能做「無交互作用的雙因子變異數分析」<br><img src="https://images.plurk.com/53Sq3dB2CHi0SIv3Xatchg.png"></p><h4 id="2-連同標題的範圍都要一起輸入"><a href="#2-連同標題的範圍都要一起輸入" class="headerlink" title="2. 連同標題的範圍都要一起輸入"></a>2. 連同標題的範圍都要一起輸入</h4><p><img src="https://images.plurk.com/5DDFCPhCFwYT3UyBpYM2iL.png"></p><h4 id="3-按下確定後可確認雙因子變異數分析之結果"><a href="#3-按下確定後可確認雙因子變異數分析之結果" class="headerlink" title="3. 按下確定後可確認雙因子變異數分析之結果"></a>3. 按下確定後可確認雙因子變異數分析之結果</h4><p><img src="https://images.plurk.com/5BZZJGKYlCg0wSnS7SWU6l.png"></p><p>第一張表格為敘述統計；第二張為ANOVA </p><ul><li>列：B -&gt; SSB</li><li>欄：A -&gt; SSA</li></ul><h2 id="比較"><a href="#比較" class="headerlink" title="比較"></a>比較</h2><p><img src="https://images.plurk.com/6NP6HG3yAcUxsA4c7ag667.png"><br>統計軟體通常直接用 p-value 判斷顯著&#x2F;不顯著</p><ul><li>p-value &lt; $\alpha$：落入拒絕域，顯著</li><li>反之。</li></ul><h1 id="有交互"><a href="#有交互" class="headerlink" title="有交互"></a>有交互</h1><p><img src="https://images.plurk.com/75z208aU5iCGfvti1xrMPx.png"><br>想要研究不同教育程度對於男女薪資的影響</p><ul><li>應變數：<ul><li>因子A：教育程度</li><li>因子B：性別<br>每一組合（AxB組合）的資料都各有三筆，這是重複試驗<br>ie. 男x國中 的資料有三筆</li></ul></li></ul><h4 id="1-同樣輸入資料，點擊-資料分析，選取-雙因子變異數分析：重複試驗"><a href="#1-同樣輸入資料，點擊-資料分析，選取-雙因子變異數分析：重複試驗" class="headerlink" title="1. 同樣輸入資料，點擊 資料分析，選取 雙因子變異數分析：重複試驗"></a>1. 同樣輸入資料，點擊 <code>資料分析</code>，選取 <code>雙因子變異數分析：重複試驗</code></h4><p><img src="https://images.plurk.com/4JbpHjMrv8T5Jb7QGdtY4j.png"></p><p><img src="https://images.plurk.com/5tg6eizaoGUXQz3f3Qhn3d.png"></p><h4 id="2-連同標題的範圍都要一起輸入-1"><a href="#2-連同標題的範圍都要一起輸入-1" class="headerlink" title="2. 連同標題的範圍都要一起輸入"></a>2. 連同標題的範圍都要一起輸入</h4><p><img src="https://images.plurk.com/5nRZPMsFMDziXR9xpySXHt.png"></p><h4 id="3-手動輸入-每一樣本的列數-3"><a href="#3-手動輸入-每一樣本的列數-3" class="headerlink" title="3. 手動輸入 每一樣本的列數 -&gt; 3"></a>3. 手動輸入 <code>每一樣本的列數</code> -&gt; 3</h4><p><img src="https://images.plurk.com/4ODMmypt04alaDKQsL6zoK.png"></p><p>得到結果：<br><img src="https://images.plurk.com/4rSXtAgPwQH0KLWNojg1Dq.png"><br>前三張都是敘述統計<br>判讀 ANOVA 表之順序：</p><ol><li>要先看交互作用之結果，由 p-value &#x3D; 0.297 可知其大於顯著水準 0.05，結論不顯著，交互作用不強烈</li><li>因為沒有交互作用，所以要看個別因子的影響力：「欄」的部分是教育程度：國中、高中、大學，p-value &#x3D; 0.0001 &lt; 顯著水準 0.05，結論顯著，表示教育程度會對薪資造成影響（不同教育程度會出現不同的薪資結果）</li><li>再來是「樣本」部分，為性別，其 p-value &#x3D; 3.53E，是非常小的值，代表結論顯著，表示性別會對薪資造成影響（不同性別會出現不同的薪資結果）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Statistics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 例外處理</title>
    <link href="/2026/02/05/Java%20%E4%BE%8B%E5%A4%96%E8%99%95%E7%90%86/"/>
    <url>/2026/02/05/Java%20%E4%BE%8B%E5%A4%96%E8%99%95%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul><li><a href="https://caterpillar.gitbooks.io/javase6tutorial/content/c10.html">第 10 章 例外處理（Exception Handling）</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10255635">【左京淳的JAVA學習筆記】第八章 例外處理</a></li><li><a href="https://medium.com/@clu1022/java%E7%AD%86%E8%A8%98-exception-%E8%88%87-error-dbdf9a9b0909">Java筆記 — Exception 與 Error</a></li></ul></blockquote><p>因為關於例外處理的種類容易搞混，查了很多資料後，寫一篇整理幫助自己理解。</p><h1 id="概覽"><a href="#概覽" class="headerlink" title="概覽"></a>概覽</h1><ul><li>java 例外的特性</li><li>例外處理簡介</li><li>語法</li><li>受檢例外（Checked Exception）、執行時期例外（Runtime Exception）</li><li>throw &amp; throws</li><li>關於自訂例外 (Custom Exception)</li></ul><h1 id="java-例外的特性"><a href="#java-例外的特性" class="headerlink" title="java 例外的特性"></a>java 例外的特性</h1><ul><li>Java 的全部例外的父類別是 <code>Throwable</code>，他下面是<ul><li>Error：記憶體不足等嚴重錯誤，難以由程式進行對應所以直接報error結束</li><li>Exception &lt;- 本文主要討論的，又分為兩大類<ul><li>受檢例外</li><li>執行期例外</li></ul></li></ul></li><li>例外 Exception 是物件，可以被實體化（new），是一個 class</li><li>例外在 java 中可以分為兩大類：(1) 受檢例外(Exception)；(2) 執行期例外(RuntimeException)</li><li>自訂例外其實只是「自訂名稱例外」，因為自訂例外時必定讓這個自訂例外 class 繼承某個例外父類別，這時就看他繼承的父類別是繼承自 (1) 受檢例外；(2) 執行期例外 哪一個，那這個自訂類別就要遵從那一種例外的規則。也就是一切都可以從「繼承」的觀念理解。<ul><li>嚴格來說規則應該這樣看，因為 RuntimeException 也是繼承自 Exception 類別的，他是 Exception 之下的特殊子類別<ul><li>規則 A：只要你的血統裡有 <code>RuntimeException</code> ，那特性就是不受檢 (Unchecked)。編譯器不管你</li><li>規則 B：你的血統裡有 <code>Exception</code>，但「沒有」 <code>RuntimeException</code>，那特性就是受檢 (Checked)。編譯器嚴格監控</li></ul></li></ul></li><li>只要是繼承自 <code>Exception</code> 類別都會有這兩種方法可以使用（RuntimeException 也是繼承 Exception ，所以 RuntimeException 和其子類別也可以用）<ol><li><code>printStackTrace()</code>：<code>void</code> 方法，會印出例外發生的地方<ul><li>會印出完整的錯誤堆疊（包含哪一行出錯、誰呼叫誰）</li></ul></li><li><code>getMessage()</code>：回傳 <code>String</code> 型態資料，是「例外發生的原因等相關資訊」<ul><li>取得簡短的錯誤描述文字</li></ul></li></ol></li></ul><hr><h1 id="例外處理簡介"><a href="#例外處理簡介" class="headerlink" title="例外處理簡介"></a>例外處理簡介</h1><p>編譯器會幫您檢查一些可能產生例外（Checked exception）的狀況，並要求您注意並處理，而對於「執行時期例外」（Runtime exception），您也可以嘗試捕捉例外並將程式回復至正常狀況，這段話的意思，其實是指 java 的例外可以分成兩種，下面詳述</p><p>如果不用例外處理的功能，那通常會用 if 判斷是來代替例外處理，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判斷使用者有無傳入參數，只有有傳入參數才可以往下跑</span><br><span class="hljs-keyword">if</span>(arr.length != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">// 正常要執行的程式碼...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但這個通常會造成處理錯誤的邏輯與處理業務的邏輯混在一起<br>所以最好還是做例外處理<br>有些預期中可能發生的例外，編譯器會提醒您先行處理，對於一些程式運行時所發生的執行時期例外，您有機會捕捉這些例外，並嘗試將程式回復至正常運作狀態</p><h1 id="語法"><a href="#語法" class="headerlink" title="語法"></a>語法</h1><p>java 中的例外處理由三個關鍵字組合而成（另外還有一個 throw 之後會提，他算是負責向外、向上拋出錯誤的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// 可能發生錯誤的程式邏輯</span><br>&#125;<br><span class="hljs-keyword">catch</span>(例外型態 例外名稱)&#123;<br><span class="hljs-comment">// 例外發生時的例外處理</span><br>&#125;<br><span class="hljs-keyword">finally</span>&#123;<br><span class="hljs-comment">// 一定會處理的區域</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>try：一個 “try” 語法所包括的區塊，必須有對應的 “catch” 區塊或是 “finally” 區塊，”try” 區塊可以搭配多個 “catch” 區塊</li><li>catch：如果有設定 “catch” 區塊，則 “finally” 區塊可有可無，如果沒有定義 “catch” 區塊，則一定要有 “finally” 區塊</li></ul><h2 id="範例：檢查函數是否有被傳入參數"><a href="#範例：檢查函數是否有被傳入參數" class="headerlink" title="範例：檢查函數是否有被傳入參數"></a>範例：檢查函數是否有被傳入參數</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckArgsDemo</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arrLen</span><span class="hljs-params">(<span class="hljs-type">int</span>[] Arr)</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// 如果沒有傳入參數，就會無法印出陣列的長度</span><br>System.out.println(Arr.length);<br>&#125;<br><span class="hljs-keyword">catch</span>(Exception e)&#123;<br>System.out.println(<span class="hljs-string">&quot;沒有傳入陣列，無法印出陣列長度&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="受檢例外（Checked-Exception）、執行時期例外（Runtime-Exception）"><a href="#受檢例外（Checked-Exception）、執行時期例外（Runtime-Exception）" class="headerlink" title="受檢例外（Checked Exception）、執行時期例外（Runtime Exception）"></a>受檢例外（Checked Exception）、執行時期例外（Runtime Exception）</h1><p>剛剛提到 java 的例外物件分成兩種，就是這兩大類</p><ol><li>受檢例外</li><li>執行期例外</li></ol><p>受檢例外指的是 <strong>所有「繼承 Exception，但不是 RuntimeException 子類」的類</strong><br>執行期例外的類別名稱叫做 <code>RuntimeException</code>，指的是超類別存在 <code>RuntimeException</code> 的類別</p><p>可以從 Java 官方文件中看到繼承關係圖<br>![[截圖 2026-02-05 下午3.10.06.png|400]]<br>可知執行期例外其實是受檢例外這個類別下的一個子類別，但他是一個特殊子類別，所以前面才說判斷一個類別是否為受檢例外，就看他的超類別是有包含 <code>RuntimeException</code></p><ul><li>有包含 <code>RuntimeException</code>：屬於執行期例外</li><li>沒包含  <code>RuntimeException</code>：屬於受檢例外</li></ul><h2 id="受檢例外（Checked-Exception）"><a href="#受檢例外（Checked-Exception）" class="headerlink" title="受檢例外（Checked Exception）"></a>受檢例外（Checked Exception）</h2><p>編譯器強制要求要做會拋出受檢例外的函數的例外處理，這個意思是如果呼叫了「會拋出受檢例外的方法」時，沒有用 try-catch 包起來，或是沒有在方法簽名上用 <code>throws</code> 宣告（告訴呼叫者這裡會出事），讓例外自動往上傳遞的話（二法擇一），程式碼連編譯都不會過。<br>可以理解成 Java 認為這種例外（錯誤）在「<strong>程式在語法與邏輯正確下仍可能發生</strong>」，所以強迫程式撰寫者先想好對策 -&gt; 處理它（try-catch） or 宣告他（throws）<br>例如 OutofMemory 這種問題，就算你程式邏輯正確可以跑，但還是有可能發生，也就是他「<strong>不可由程式邏輯完全避免</strong>」</p><p>常見的應用場景是檔案讀寫、網路連線、資料庫操作<br>常見的受檢例外物件有：</p><ul><li>IOException：輸入輸出例外</li><li>SQLException：SQL 資料庫例外</li><li>ClassNotFoundException：找不到類別</li><li>InterruptedException：執行緒中斷</li><li>FileNotFoundException：找不到檔案</li></ul><p>對於 Checked Exception，必須使用 <code>throws</code> 宣告或 <code>try-catch</code> 處理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReader</span> &#123;<br>    <span class="hljs-comment">// 方法1：使用 throws 宣告</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">readFile</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.FileReader(path));<br>        <span class="hljs-keyword">return</span> reader.readLine();<br>    &#125;<br><br>    <span class="hljs-comment">// 方法2：使用 try-catch 處理</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">readFileSafe</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.FileReader(path));<br>            <span class="hljs-keyword">return</span> reader.readLine();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="執行時期例外（Runtime-Exception）"><a href="#執行時期例外（Runtime-Exception）" class="headerlink" title="執行時期例外（Runtime Exception）"></a>執行時期例外（Runtime Exception）</h2><p>這就是非受檢例外，通常代表 <strong>「程式設計師寫出的邏輯漏洞」</strong>（也就是 Bug）。Java 認為這些錯誤應該透過 <strong>「修正程式碼」</strong> 來避免，而不是用 <code>try-catch</code> 來掩蓋<br>所以編譯器不會強制程式撰寫者去預先處理這些執行期例外，但若是想要預先處理也可以。<br>常見的應用場景是陣列存取、物件操作、數學運算<br>常見的執行期例外有：</p><ul><li>NullPointerException：空指標例外（簡稱 NPE）<ul><li>說明：呼叫到內容是 null 的物件資料</li></ul></li><li>ArrayIndexOutOfBoundException：陣列索引越界</li><li>ClassCastException：資料型態轉型例外</li><li>IllegalArgumentException：參數的格式錯誤例外</li><li>NumberFormatException：數字格式例外<ul><li>說明：例如說把字串 <code>&quot;abc&quot;</code> 轉成數字的時候</li></ul></li><li>ArithmeticException：算數例外，例如除法時除以 0</li></ul><hr><h1 id="throws-throw"><a href="#throws-throw" class="headerlink" title="throws &amp; throw"></a>throws &amp; throw</h1><p>前面說的 try-catch 法是當場處理例外的方式，但有時候我們不想在方法中直接處理例外，想要由呼叫這個方法的呼叫者來處理，就可以利用 <code>throws</code> 關鍵字來把例外向外拋，傳給上一層、上上層，最後必要有一個 <code>try-catch</code> 來處理它<br>例如 java.ioBufferedReader 的 readLine() 方法就聲明會丟出 java.io.IOException</p><p>throw 跟 throws 的差別：</p><ul><li>throw：動詞，拋出例外</li><li>throws：名詞，宣告此方法可能拋出的例外</li></ul><h2 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h2><ul><li>位置：寫在方法簽名後</li><li>用途：宣告此方法可能拋出的例外</li><li>語法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> 例外型態&#123;<br><span class="hljs-comment">// 方法內容</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>對於有在簽名聲明 throws 例外型態的方法，在呼叫這種方法時，呼叫者需要選擇處理（try-catch）或繼續往外丟（throws））<br>當方法上使用 “throws” 宣告丟出例外時，意味著呼叫該方法的呼叫者必須處理這些例外</p></blockquote><p>對於宣告了 <code>throws 受檢例外</code> 的方法，呼叫者 <strong>必須</strong> 在以下兩者中選擇其一（編譯器強制）：</p><ol><li><strong>自行處理 (Handle)</strong>：使用 <code>try-catch</code> 包覆呼叫程式碼。</li><li><strong>繼續往外丟 (Declare)</strong>：在自己的方法上也宣告 <code>throws</code>，交給更上層處理。</li></ol><p>那什麼時候用 throw？</p><ul><li><strong>你是「傳遞者」時（不需要寫 <code>throw</code>）</strong><ul><li>當你呼叫的方法（例如 <code>FileReader</code>）本身就會拋出例外。</li><li>你只需要用 <code>throws</code> 開門讓它飛出去，不需要自己寫 <code>throw new...</code>。</li></ul></li><li><strong>你是「肇事者」時（需要寫 <code>throw</code>）</strong><ul><li>當<strong>商業邏輯錯誤</strong>發生（例如：輸入負數、餘額不足），但這在 Java 語法上是合法的。</li><li>你必須<strong>手動</strong>製造錯誤並丟出：<code>throw new Exception(&quot;錯誤訊息&quot;);</code>。</li></ul></li></ul><table><thead><tr><th><strong>例外種類</strong></th><th><strong>範例</strong></th><th><strong>編譯器態度</strong></th><th><strong>呼叫者是否強迫處理 (try-catch&#x2F;throws)</strong></th></tr></thead><tbody><tr><td><strong>受檢例外</strong> (Checked)</td><td><code>IOException</code>, <code>SQLException</code></td><td><strong>嚴格</strong> (紅燈)</td><td><strong>是 (必須二選一)</strong></td></tr><tr><td><strong>執行期例外</strong> (Runtime)</td><td><code>NullPointerException</code>, <code>ArithmeticException</code></td><td><strong>放任</strong> (綠燈)</td><td><strong>否</strong> (可處理也可不處理，通常建議改程式邏輯)</td></tr><tr><td><strong>自訂例外</strong> (Custom)</td><td>取決於繼承誰</td><td><strong>(看爸爸是誰)</strong></td><td><strong>(看爸爸是誰)</strong></td></tr><tr><td>例如:</td><td></td><td></td><td></td></tr></tbody></table><ul><li><code>java.io.*</code> 提供的FileReader類的建構式，發生例外時會throws FileNotFoundException。<br>  這個例外不屬於RuntimeException的子類，所以”必須”指定例外處理方法。  </li><li><code>java.lang.*</code> 包提供的 Integer 類的 parseInt() 方法出錯時會throws NumberFormatException<br>  這個例外屬於 RuntimeException 的子類，所以不一定要指定例外處理方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sample</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//不一定要處理的例外</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.parseInt(<span class="hljs-string">&quot;10&quot;</span>);<br>    <br>    <span class="hljs-comment">//一定要處理的例外</span><br>    <span class="hljs-type">FileReader</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;Test.txt&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因為 FileReader 沒有針對她處理例外，所以在編譯階段就出現錯誤：</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pony">ex1.java:<span class="hljs-number">9</span>: <span class="hljs-keyword">error</span>: unreported exception <span class="hljs-type">FileNotFoundException</span>; must <span class="hljs-keyword">be</span> caught <span class="hljs-keyword">or</span> declared to <span class="hljs-keyword">be</span> thrown<br>        <span class="hljs-type">FileReader</span> r = <span class="hljs-keyword">new</span> <span class="hljs-type">FileReader</span>(<span class="hljs-string">&quot;Test.txt&quot;</span>);<br>                       ^<br><span class="hljs-number">1</span> <span class="hljs-keyword">error</span><br></code></pre></td></tr></table></figure><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><ul><li>位置：寫在方法內部，<code>&#123;&#125;</code> 裡面</li><li>用途：實際去拋出例外</li><li>語法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// 方法內容</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> 例外型態(<span class="hljs-string">&quot;錯誤訊息&quot;</span>);<br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 假設例外發生，那這後面的程式碼都不會被執行</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>呼叫這個 <code>f1</code> 的呼叫者也必須要處理這個例外（<code>try-catch</code> or <code>throws</code>）<br>適用於「我們想要自己定義什麼值是正常、什麼值是異常值」的時候，而非遵從 Java 原先的設定<br>就可以用 throw 手動丟出例外</li></ul><h2 id="何時只用-throws；何時-throws-throw-都要用？"><a href="#何時只用-throws；何時-throws-throw-都要用？" class="headerlink" title="何時只用 throws；何時 throws, throw 都要用？"></a>何時只用 throws；何時 throws, throw 都要用？</h2><p>這個問題的答案取決於「這個例外是誰發現的？」<br>throw 有點像是你手動去觸發丟出這個例外</p><table><thead><tr><th></th><th>情況</th><th>說明</th></tr></thead><tbody><tr><td>不需 throw，只要寫 throws</td><td>錯誤是 Java 系統 (JVM) 或 函式庫 發現的</td><td>如果這個錯誤是發生在底層（例如硬碟壞了、網路斷了、除以零），Java 原本寫好的程式碼裡<strong>已經</strong>幫你寫好 <code>throw</code> 了，那程式撰寫者就不用自己再 throw 一次</td></tr><tr><td>throw, throws 都要寫</td><td>錯誤是「你的商業邏輯」發現的 (Java 覺得沒錯，但你覺得有錯)</td><td>即便 throw 出的是 Java <strong>內建</strong>的 <code>Exception</code>（如例如），只要這個錯誤是**「違反你的規定」**（而非違反 Java 的語法或系統規定），你就必須手動 <code>throw</code></td></tr></tbody></table><p>範例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第一種：不需 throw，只要寫 throws</span><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassiveReader</span> &#123;<br><br>    <span class="hljs-comment">// 這裡只需要寫 throws (宣告)，不用寫 throw (動作)</span><br>    <span class="hljs-comment">// 因為 FileReader 內部已經寫好 throw 了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readStandardFile</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <br>        <span class="hljs-comment">// 這一行執行時，如果 path 指向的檔案不存在</span><br>        <span class="hljs-comment">// Java 底層會自動 throw new FileNotFoundException()</span><br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(path); <br>        <br>        System.out.println(<span class="hljs-string">&quot;檔案開啟成功&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>這時因為 <code>PassiveReader </code>是把 <code>FileNotFoundException</code> 這個受檢例外純粹往上一層呼叫 <code>PassiveReader</code> 這個方法的人丟過去，假設是由 <code>main</code> 呼叫 <code>PassiveReader</code> ，那 <code>main</code> 有兩種選擇去處理這個被丟上來的例外：<ol><li>直接在 <code>main</code> 裡面寫 <code>try-catch</code></li><li>若在 main 宣告 throws，例外未被捕捉時，JVM 會印出 stack trace 並正常結束程式（abnormal termination）<br>  <code>FileReader</code> 內部已經做了 throw new FileNotFoundException()，但剩餘 try-catch 的部分還是需要處理</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第二種：throw, throws 都要寫</span><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrictReader</span> &#123;<br><br>    <span class="hljs-comment">// 這裡還是要寫 throws (宣告)，因為你等一下要丟炸彈了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readSecureFile</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <br>        <span class="hljs-comment">// 【你的自訂邏輯】</span><br>        <span class="hljs-comment">// 假設我們規定：絕對不允許讀取 &quot;config.xml&quot; 這種敏感檔案</span><br>        <span class="hljs-comment">// 就算硬碟裡真的有這個檔案，我們也要騙呼叫者說「找不到」</span><br>        <span class="hljs-keyword">if</span> (path.equals(<span class="hljs-string">&quot;config.xml&quot;</span>)) &#123;<br>            <br>            <span class="hljs-comment">// 這裡必須寫 throw！</span><br>            <span class="hljs-comment">// 因為 Java 不知道你想隱藏這個檔案，你必須主動丟出炸彈</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>(<span class="hljs-string">&quot;權限不足，假裝找不到此檔案: &quot;</span> + path);<br>        &#125;<br><br>        <span class="hljs-comment">// 如果不是敏感檔案，才真的去讀 (這裡如果讀不到，FileReader 也會幫你丟)</span><br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(path);<br>        System.out.println(<span class="hljs-string">&quot;檔案開啟成功&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="關於自訂例外-Custom-Exception"><a href="#關於自訂例外-Custom-Exception" class="headerlink" title="關於自訂例外 (Custom Exception)"></a>關於自訂例外 (Custom Exception)</h1><blockquote><p>自訂例外其實只是「自訂名稱例外」，因為自訂例外時必定讓這個自訂例外 class 繼承某個例外父類別</p></blockquote><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 繼承自一個受檢例外，那 myException 也是受檢例外</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IOException</span>&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 繼承自父類別是 RuntimeException 的執行期例外 IllegalArgumentException，所以 myE 是一個執行期例外</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myE</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IllegalArgumentException</span>&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自訂例外是否被編譯器視為需要被處理？"><a href="#自訂例外是否被編譯器視為需要被處理？" class="headerlink" title="自訂例外是否被編譯器視為需要被處理？"></a>自訂例外是否被編譯器視為需要被處理？</h2><p>自訂例外的行為，完全取決於你讓它<strong>繼承 (extends)</strong> 了哪一個類別：</p><ol><li><strong>繼承 <code>Exception</code></strong> → 它就變成 <strong>受檢例外</strong>。<ul><li><strong>規則：</strong> 比照受檢例外，<strong>強制</strong>呼叫者處理。</li><li><em>用途：</em> 重要的業務邏輯錯誤（如 <code>餘額不足Exception</code>），強迫上層一定要寫程式碼來處理。</li></ul></li><li><strong>繼承 <code>RuntimeException</code></strong> → 它就變成 <strong>執行期例外</strong>。<ul><li><strong>規則：</strong> 比照執行期例外，<strong>不強迫</strong>呼叫者處理。</li><li><em>用途：</em> 參數錯誤或邏輯漏洞（如 <code>參數無效Exception</code>）。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-comment">//Write your code here</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">power</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> p)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span> || p&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;n and p should be non-negative&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)Math.pow(n,p);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-keyword">while</span> (t-- &gt; <span class="hljs-number">0</span>) &#123;<br>        <br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> in.nextInt();<br>            <span class="hljs-type">Calculator</span> <span class="hljs-variable">myCalculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> myCalculator.power(n, p);<br>                System.out.println(ans);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                System.out.println(e.getMessage());<br>            &#125;<br>        &#125;<br>        in.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
